<!doctype html>
<html class="no-js" lang="zh-CN">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="索引" href="../genindex.html" /><link rel="search" title="搜索" href="../search.html" /><link rel="copyright" title="版权所有" href="../copyright.html" /><link rel="next" title="使用 Python 处理地理空间数据库" href="working.html" /><link rel="prev" title="商业空间数据库" href="commerical.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2023.03.27 -->
        <title>建议的最佳做法 - python地理空间开发 1.0 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/mystyles.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">python地理空间开发 1.0 文档</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">python地理空间开发 1.0 文档</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">内容</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about_author.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about_reviewers.html">审稿人简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch1/index.html">1 使用 Python 进行地理空间开发</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch1/python.html">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/geo_dev.html">地理空间开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/applications.html">地理空间开发的应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/recent_dev.html">最新动态</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch2/index.html">2 GIS</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch2/core_concepts.html">核心 GIS 概念</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/gis_data_format.html">GIS 数据格式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/working.html">手动处理 GIS 数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch3/index.html">3 用于地理空间开发的 Python 库</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch3/rw.html">读取和写入地理空间数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/dealing_proj.html">处理投影</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/analyzing.html">分析和处理地理空间数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/visualizing.html">可视化地理空间数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch4/index.html">4 地理空间数据来源</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch4/vector_format.html">矢量格式的地理空间数据来源</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/raster_format.html">栅格格式地理空间数据源</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/other_format.html">其他类型地理空间数据的来源</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/choosing_format.html">选择地理空间数据源</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch5/index.html">5 使用 Python 处理地理空间数据</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch5/pre-req.html">先决条件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/rw.html">读取和写入地理空间数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/changing.html">更改基准和投影</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/representing.html">表示和存储地理空间数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/performing.html">执行地理空间计算</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/converting.html">转换和标准化几何和距离单位</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/exercises.html">练习</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">6 数据库中的 GIS</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="spatially.html">空间数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="spatially-indexes.html">空间索引</a></li>
<li class="toctree-l2"><a class="reference internal" href="open-source.html">支持空间功能的开源数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="commerical.html">商业空间数据库</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">建议的最佳做法</a></li>
<li class="toctree-l2"><a class="reference internal" href="working.html">使用 Python 处理地理空间数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch7/index.html">7 使用空间数据</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch7/about-distal.html">关于 DISTAL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/designing.html">设计和构建数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/downloading.html">下载数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/importing-data.html">导入数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/implementing.html">实现 DISTAL 应用程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/aplication.html">应用程序审查和改进</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch8/index.html">8 使用 Python 和 Mapnik 生成地图</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch8/introducing.html">Mapnik 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch8/creating.html">创建示例地图</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch8/mapnik.html">Mapnik 深度介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch8/mapgenerator.html">重新审视 MapGenerator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch8/mapdefinition.html">地图定义文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch8/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch9/index.html">9 整合所有要素——完整的地图系统</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch9/about-shapeditor.html">关于 ShapeEditor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/designing-shape.html">设计 ShapeEditor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/prerequisites.html">先决条件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/the-structure-ofdjango.html">Django 应用程序的结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/settingup-database.html">设置数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/settingup-shapeeditor.html">设置 ShapeEditor 项目</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/defining-shapeditor.html">定义 ShapeEditor 的应用程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/creating-shared.html">创建共享应用程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/defining-datamodel.html">定义数据模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/playing.html">玩转管理系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch10/index.html">10 ShapeEditor – 实现列表视图、导入和导出</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch10/implementing.html">实现“列出 Shapefile”视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch10/importing.html">导入 Shapefile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch10/exporting.html">导出 shapefiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch10/summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ch11/index.html">11 ShapeEditor – 选择和编辑特征</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch11/selecting.html">选择要编辑的要素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch11/editring.html">编辑要素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch11/adding.html">添加要素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch11/deleting.html">删除要素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch11/deleting-shapefiles.html">删除 shapefiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch11/using.html">使用 ShapeEditor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch11/further.html">进一步改进和增强</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch11/summary.html">小结</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="id1">
<h1>建议的最佳做法<a class="headerlink" href="#id1" title="此标题的永久链接">#</a></h1>
<p>Recommended best practices</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--0-input--1" name="tab-set--0" type="radio"><label class="tab-label" for="tab-set--0-input--1">中文</label><div class="tab-content docutils container">
<p>在本节中，我们将介绍一些可以采取的实际措施，以确保地理空间数据库尽可能高效、有效地运行。</p>
</div>
<input class="tab-input" id="tab-set--0-input--2" name="tab-set--0" type="radio"><label class="tab-label" for="tab-set--0-input--2">英文</label><div class="tab-content docutils container">
<p>In this section, we will look at a number of practical things you can do to ensure your geospatial databases work as efficiently and effectively as possible.</p>
</div>
</div>
<section id="id2">
<h2>使用数据库跟踪空间参考<a class="headerlink" href="#id2" title="此标题的永久链接">#</a></h2>
<p>Using the database to keep track of spatial references</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--1-input--1" name="tab-set--1" type="radio"><label class="tab-label" for="tab-set--1-input--1">中文</label><div class="tab-content docutils container">
<p>正如我们在前几章中所看到的，不同的地理空间数据使用不同的坐标系统、基准面和投影。例如，考虑以下两个几何对象：</p>
<a class="with-border reference internal image-reference" href="../_images/198-0.png"><img alt="../_images/198-0.png" class="with-border align-center" src="../_images/198-0.png" style="width: 473.2px; height: 178.5px;" /></a>
<p>几何体被表示为一系列坐标，这些坐标仅仅是数字。单独来看，这些数字并没有什么特别的用途——你需要通过识别几何体使用的空间参考（坐标系统、基准面和投影）将这些坐标定位到地球表面。</p>
<p>在这个例子中，POLYGON使用的是WGS84基准面下的未投影的纬度/经度坐标，而LINESTRING使用的是使用UTM Zone 12N投影定义的以米为单位的坐标。一旦知道了空间参考，就可以将这两个几何体放置到地球表面。这揭示了这两个几何体实际上是重叠的：</p>
<a class="with-border reference internal image-reference" href="../_images/199-0.png"><img alt="../_images/199-0.png" class="with-border align-center" src="../_images/199-0.png" style="width: 198.0px; height: 126.0px;" /></a>
<p>在除最简单的数据库之外，建议你直接在数据库中为每个要素存储空间参考。这使得跟踪每个要素使用的空间参考变得更加容易。它还使得你编写的查询和数据库命令能够意识到空间参考，并使你能够根据需要在空间查询中将几何体从一个空间参考转换到另一个空间参考。</p>
<p>空间参考通常使用一个简单的整数值称为 <strong>空间参考标识符（SRID）</strong> 来表示。尽管你可以选择任意的SRID值来表示各种空间参考，但强烈建议你使用 <strong>欧洲石油勘探组（EPSG）</strong> 编号作为标准SRID值。使用这一国际公认的标准可以使你的数据与其他数据库互换，并允许像OGR和Mapnik这样的工具识别你的数据使用的空间参考。</p>
<p>要了解更多关于EPSG编号和SRID值的一般信息，请参考：</p>
<p><a class="reference external" href="http://epsg-registry.org">http://epsg-registry.org</a></p>
<p>你之前已经见过SRID值。例如，在本章的使用SpatiaLite部分，我们遇到了以下SQL语句：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">AddGeometryColumn</span><span class="p">(</span><span class="s1">&#39;cities&#39;</span><span class="p">,</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span><span class="mi">4326</span><span class="p">,</span><span class="s1">&#39;POLYGON&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>值4326是用来标识特定空间参考的SRID，在这个例子中是WGS84经纬度参考（使用WGS84基准面的未投影的经纬度坐标）。</p>
<p>PostGIS和SpatiaLite都向你的空间数据库添加了一个特殊的表格，叫做spatial_ref_sys。这个表格预加载了超过3000个常用空间参考的列表，所有这些参考都由EPSG编号标识。由于SRID值是这个表格的主键，访问数据库的工具可以参考此表格，使用PROJ.4库进行实时坐标转换。即使你使用的是MySQL，尽管它不提供spatial_ref_sys表格或其他直接支持坐标转换的功能，但你也应该使用标准的EPSG编号作为空间参考。</p>
<p>请注意，所有三个开源空间数据库都允许你在从WKT导入时为几何体关联SRID值：</p>
<ul class="simple">
<li><p>MySQL: <em>GeometryFromText(wkt, [srid])</em></p></li>
<li><p>PostGIS: <em>ST_GeometryFromText(wkt, [srid])</em></p></li>
<li><p>SpatiaLite: <em>GeometryFromText(wkt, [srid])</em></p></li>
</ul>
<p>虽然SRID值是可选的，但你应该尽可能使用它来告知数据库你的几何体使用的是哪个空间参考。事实上，如果一个列已经设置为使用特定的SRID值，PostGIS和SpatiaLite都要求你使用正确的SRID值。这可以防止你在一个表格中混合使用不同的空间参考。</p>
</div>
<input class="tab-input" id="tab-set--1-input--2" name="tab-set--1" type="radio"><label class="tab-label" for="tab-set--1-input--2">英文</label><div class="tab-content docutils container">
<p>As we’ve seen in earlier chapters, different sets of geospatial data use different
coordinate systems, datums, and projections. Consider, for example, the following
two geometry objects:</p>
<a class="with-border reference internal image-reference" href="../_images/198-0.png"><img alt="../_images/198-0.png" class="with-border align-center" src="../_images/198-0.png" style="width: 473.2px; height: 178.5px;" /></a>
<p>The geometries are represented as a series of coordinates, which are nothing more
than numbers. By themselves, these numbers aren’t particularly useful—you need
to position these coordinates onto the Earth’s surface by identifying the spatial
reference (coordinate system, datum and projection) used by the geometry.</p>
<p>In this case, the POLYGON is using unprojected lat/long coordinates in the WGS84
datum, while the LINESTRING is using coordinates defined in meters using the
UTM Zone 12N projection. Once you know the spatial reference, you can place
the two geometries onto the Earth’s surface. This reveals that the two geometries
actually overlap:</p>
<a class="with-border reference internal image-reference" href="../_images/199-0.png"><img alt="../_images/199-0.png" class="with-border align-center" src="../_images/199-0.png" style="width: 198.0px; height: 126.0px;" /></a>
<p>In all but the most trivial databases, it is recommended that you store the spatial
reference for each feature directly in the database itself. This makes it easy to keep
track of which spatial reference is used by each feature. It also allows the queries
and database commands you write to be aware of the spatial reference, and enables
you to transform geometries from one spatial reference to another as necessary in
your spatial queries.</p>
<p>Spatial references are generally referred to using a simple integer value called a
<strong>Spatial Reference Identifier (SRID)</strong>. While you could choose arbitrary SRID values
to represent various spatial references, it is strongly recommended that you use the
<strong>European Petroleum Survey Group (EPSG)</strong> numbers as standard SRID values.
Using this internationally-recognized standard makes your data interchangeable
with other databases, and allows tools such as OGR and Mapnik to identify the
spatial reference used by your data.</p>
<p>To learn more about EPSG numbers, and SRID values in general, please refer to:</p>
<p><a class="reference external" href="http://epsg-registry.org">http://epsg-registry.org</a></p>
<p>You have seen SRID values before. For example, in the Using SpatiaLite section of
this chapter, we encountered the following SQL statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">AddGeometryColumn</span><span class="p">(</span><span class="s1">&#39;cities&#39;</span><span class="p">,</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span><span class="mi">4326</span><span class="p">,</span><span class="s1">&#39;POLYGON&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The value 4326 is the SRID used to identify a particular spatial reference, in this
case the WGS84 Long Lat reference (unprojected lat/long coordinates using the
WGS84 datum).</p>
<p>Both PostGIS and SpatiaLite add a special table to your spatially-enabled database
called spatial_ref_sys. This table comes preloaded with a list of over 3,000
commonly-used spatial references, all identified by EPSG number. Because the SRID
value is the primary key into this table, tools that access the database can refer to this
table to perform on-the-fly coordinate transformations using the PROJ.4 library. Even
if you are using MySQL, which doesn’t provide a spatial_ref_sys table or other
direct support for coordinate transformations, you should be using standard EPSG
numbers for your spatial references.</p>
<p>Note that all three open source spatial databases allow you to associate an SRID
value with a geometry when importing from WKT:</p>
<ul class="simple">
<li><p>MySQL: <em>GeometryFromText(wkt, [srid])</em></p></li>
<li><p>PostGIS: <em>ST_GeometryFromText(wkt, [srid])</em></p></li>
<li><p>SpatiaLite: <em>GeometryFromText(wkt, [srid])</em></p></li>
</ul>
<p>While the SRID value is optional, you should use this wherever possible to tell the
database which spatial reference your geometry is using. In fact, both PostGIS and
SpatiaLite require you to use the correct SRID value if a column has been set up
to use a particular SRID. This prevents you from using mixing spatial references
within a table.</p>
</div>
</div>
</section>
<section id="id3">
<h2>使用适合您数据的空间参考<a class="headerlink" href="#id3" title="此标题的永久链接">#</a></h2>
<p>Using the appropriate spatial reference for your data</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--2-input--1" name="tab-set--2" type="radio"><label class="tab-label" for="tab-set--2-input--1">中文</label><div class="tab-content docutils container">
<p>当你将空间数据导入数据库时，它将使用特定的空间参考。这并不意味着它必须保持在该空间参考中。实际上，在许多情况下，将数据转换为适合你特定需求的空间参考会更加高效和准确。当然，“适当的”空间参考取决于你想要实现的目标。</p>
<p>除了PostGIS及其新的地理数据类型外，所有三个空间数据库都假定坐标存在于笛卡尔平面上——也就是说，它们使用的是投影坐标。如果你将未投影的坐标（纬度和经度值）存储在数据库中，那么你将会受到限制。肯定地说，你可以在数据库中使用未投影的地理坐标来比较两个要素（例如，查看一个要素是否与另一个要素相交），并且你可以快速存储和检索地理空间数据。然而，任何涉及面积或距离的计算几乎都是没有意义的。</p>
<p>例如，考虑一下如果你要求MySQL计算一个LINESTRING几何体的长度会发生什么：</p>
<div class="highlight-mysql notranslate"><div class="highlight"><pre><span></span><span class="n">mysql</span><span class="o">&gt;</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">GLength</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">roads</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="mi">9513</span><span class="p">;</span>
<span class="o">+-------------------+</span>
<span class="o">|</span><span class="w"> </span><span class="n">GLength</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
<span class="o">|</span>
<span class="o">+-------------------+</span>
<span class="o">|</span><span class="w"> </span><span class="mf">192.3644911426572</span><span class="w"> </span><span class="o">|</span>
<span class="o">+-------------------+</span>
</pre></div>
</div>
<p>如果你的数据是未投影的纬度/经度坐标，结果的“长度”将是一个十进制度数值。不幸的是，这个数字并没有什么实际用途。你不能简单地假设十进制度数“长度”和地球表面上的实际长度之间有某种简单的关系，例如通过乘以某个常数来得出以米为单位的真实长度。事实上，这个所谓的“长度”值唯一的用途可能就是用来粗略估算真实长度，正如我们在上一章中所做的，通过过滤出明显离目标点太远的要素。</p>
<p>如果你确实需要对你的地理空间数据进行长度和面积计算（并且很可能在某个阶段你需要这样做），你有三个选择：</p>
<ul class="simple">
<li><p>使用支持未投影坐标的数据库</p></li>
<li><p>在执行长度或距离计算之前将要素转换为投影坐标</p></li>
<li><p>从一开始就将几何体存储为投影坐标</p></li>
</ul>
<p>让我们更详细地考虑这些选项。</p>
</div>
<input class="tab-input" id="tab-set--2-input--2" name="tab-set--2" type="radio"><label class="tab-label" for="tab-set--2-input--2">英文</label><div class="tab-content docutils container">
<p>When you import spatial data into your database, it will be in a particular spatial
reference. This doesn’t mean, though, that it has to stay in that spatial reference.
In many cases, it will be more efficient and accurate to transform your data into
the most appropriate spatial reference for your particular needs. Of course,
“appropriate” depends on what you want to achieve.</p>
<p>With the exception of PostGIS and its new geography type, all three spatial databases
assume that coordinates exist on a Cartesian plane—that is, that you are using
projected coordinates. If you store unprojected coordinates (latitude and longitude
values) in the database, you will be limited in what you can do. Certainly, you can
use unprojected geographic coordinates in a database to compare two features (for
example, to see if one feature intersects with another), and you will be able to store
and retrieve geospatial data quickly. However, any calculation that involves area
or distance will be all but meaningless.</p>
<p>Consider, for example, what would happen if you asked MySQL to calculate the
length of a LINESTRING geometry:</p>
<div class="highlight-mysql notranslate"><div class="highlight"><pre><span></span><span class="n">mysql</span><span class="o">&gt;</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">GLength</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">roads</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="mi">9513</span><span class="p">;</span>
<span class="o">+-------------------+</span>
<span class="o">|</span><span class="w"> </span><span class="n">GLength</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
<span class="o">|</span>
<span class="o">+-------------------+</span>
<span class="o">|</span><span class="w"> </span><span class="mf">192.3644911426572</span><span class="w"> </span><span class="o">|</span>
<span class="o">+-------------------+</span>
</pre></div>
</div>
<p>If your data was in unprojected lat/long coordinates, the resulting “length” would be
a number in decimal degrees. Unfortunately, this number is not particularly useful.
You can’t assume a simple relationship between the decimal degree “length” and
the actual length on the Earth’s surface, for example multiplying by some constant
to yield the true length in meters. The only thing is that this so-called “length” value
could be used for is to give a very rough estimate of the true length, as we did in the
previous chapter to filter out features obviously too far away from a desired point.</p>
<p>If you do need to perform length and area calculations on your geospatial data (and
it is likely that you will need to do this at some stage), you have three options:</p>
<ul class="simple">
<li><p>Using a database that supports unprojected coordinates</p></li>
<li><p>Transform the features into projected coordinates before performing the length or distance calculation</p></li>
<li><p>Store your geometries in projected coordinates from the outset</p></li>
</ul>
<p>Let’s consider each of these options in more detail.</p>
</div>
</div>
<section id="id4">
<h3>选项 1 – 使用支持地理的数据库<a class="headerlink" href="#id4" title="此标题的永久链接">#</a></h3>
<p>Option 1 – using a database that supports geographies</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--3-input--1" name="tab-set--3" type="radio"><label class="tab-label" for="tab-set--3-input--1">中文</label><div class="tab-content docutils container">
<p>在我们正在考虑的开源数据库中，只有PostGIS能够通过使用相对较新的地理数据类型直接处理未投影坐标。不幸的是，地理数据类型存在一些重大限制，这使得它并不是一个理想的解决方案：</p>
<ul class="simple">
<li><p>在未投影坐标上执行计算的时间大约是使用投影（笛卡尔）坐标执行相同计算所需时间的一个数量级</p></li>
<li><p>地理数据类型仅支持WGS84基准面上的纬度/经度值（SRID 4326）</p></li>
<li><p>许多适用于投影坐标的函数尚不支持地理数据类型</p></li>
</ul>
<p>由于这些原因，以及地理数据类型仅由PostGIS支持，在本书中我们将不会使用地理列。</p>
</div>
<input class="tab-input" id="tab-set--3-input--2" name="tab-set--3" type="radio"><label class="tab-label" for="tab-set--3-input--2">英文</label><div class="tab-content docutils container">
<p>Of the open source databases we are considering, only PostGIS has the ability to
work directly with unprojected coordinates, through the use of the relatively-new
geography type. Unfortunately, the geography type has some major limitations
which make this a less than ideal solution:</p>
<ul class="simple">
<li><p>Performing calculations on unprojected coordinates takes approximately an order of magnitude longer than performing the same calculations using projected (Cartesian) coordinates</p></li>
<li><p>The geography type only supports lat/long values on the WGS84 datum (SRID 4326)</p></li>
<li><p>Many of the functions available for projected coordinates are not yet supported by the geography type</p></li>
</ul>
<p>For these reasons, as well as the fact that they are only supported by PostGIS, we will not be using geography columns in this book.</p>
</div>
</div>
</section>
<section id="id5">
<h3>选项 2 – 根据需要转换要素<a class="headerlink" href="#id5" title="此标题的永久链接">#</a></h3>
<p>Option 2 – transform features as required</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--4-input--1" name="tab-set--4" type="radio"><label class="tab-label" for="tab-set--4-input--1">中文</label><div class="tab-content docutils container">
<p>另一种可能性是将数据存储为未投影的纬度/经度坐标，并在计算距离或面积之前将坐标转换为投影坐标系统。虽然这种方法是可行的，并且能够得到准确的结果，但你应该小心使用这种方法，因为（a）你可能会忘记在计算之前将坐标转换为投影坐标系统，以及（b）对大量几何图形进行动态转换非常耗时。</p>
<p>尽管存在这些问题，但在某些情况下，存储未投影坐标是有意义的。我们将稍后探讨这种情况。</p>
</div>
<input class="tab-input" id="tab-set--4-input--2" name="tab-set--4" type="radio"><label class="tab-label" for="tab-set--4-input--2">英文</label><div class="tab-content docutils container">
<p>Another possibility is to store your data in unprojected lat/long coordinates, and transform the coordinates into a projected coordinate system before you calculate the distance or area. While this will work, and will give you accurate results, you should beware of doing this because (a) you may well forget to transform into a projected coordinate system before making the calculation, and (b) performing on-the-fly transformations of large numbers of geometries is very time-consuming.</p>
<p>Despite these problems, there are situations where storing unprojected coordinates makes sense. We will look at this shortly.</p>
</div>
</div>
</section>
<section id="id6">
<h3>选项 3 – 从一开始就转换要素<a class="headerlink" href="#id6" title="此标题的永久链接">#</a></h3>
<p>Option 3 – transform features from the outset</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--5-input--1" name="tab-set--5" type="radio"><label class="tab-label" for="tab-set--5-input--1">中文</label><div class="tab-content docutils container">
<p>因为将特征从一个空间参考系统转换到另一个系统相当耗时，所以通常在导入数据时一次性进行转换，并将其存储在已经转换为投影坐标系统的数据库中是更为合理的选择。</p>
<p>这样做，你将能够快速且准确地执行所需的空间计算。然而，正如我们将在下一节中看到的，某些情况下这并不是最好的选择。</p>
</div>
<input class="tab-input" id="tab-set--5-input--2" name="tab-set--5" type="radio"><label class="tab-label" for="tab-set--5-input--2">英文</label><div class="tab-content docutils container">
<p>Because transforming features from one spatial reference to another is rather time-
consuming, it often makes sense to do this once, at the time you import your data,
and store it in the database already converted to a projected coordinate system.</p>
<p>Doing this, you will be able to perform your desired spatial calculations quickly
and accurately. However, there are situations where this is not the best option,
as we will see in the next section.</p>
</div>
</div>
</section>
<section id="id7">
<h3>何时使用非投影坐标<a class="headerlink" href="#id7" title="此标题的永久链接">#</a></h3>
<p>When to use unprojected coordinates</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--6-input--1" name="tab-set--6" type="radio"><label class="tab-label" for="tab-set--6-input--1">中文</label><div class="tab-content docutils container">
<p>正如我们在第2章中看到的，GIS中将地球三维表面上的特征投影到二维笛卡尔平面上是无法做到完美的。这是一个数学公理，任何投影都会存在误差。</p>
<p>不同的地图投影通常是为了保持地球表面某一部分的距离或面积等值而选择的。例如，墨卡托投影在热带地区准确，但会扭曲靠近极地的特征。</p>
<p>由于这种不可避免的扭曲，投影坐标在地理数据仅覆盖地球表面一部分区域时效果最好。如果你的数据仅涉及奥地利，那么使用投影坐标系统会非常有效。但如果数据包括奥地利和澳大利亚的特征，那么对这两组特征使用相同的投影坐标将再次产生不准确的结果。</p>
<p>因此，一般来说，对于仅覆盖地球表面一部分区域的数据，最好使用投影坐标系统，但如果你需要存储涵盖地球大部分区域的数据，则未投影坐标将是更好的选择。</p>
<p>当然，使用未投影坐标也会带来自身的问题，正如之前所讨论的。这就是为什么建议根据你的特定需求使用适当的空间参考；什么是适合你的，取决于你需要存储的数据以及你打算如何使用它。</p>
<p>找到适合的方法的最佳方式是进行实验；尝试将数据以两种空间参考导入，并编写一些测试程序来处理导入的数据。这样你就能知道哪种空间参考最快且最容易使用，而不需要猜测。</p>
</div>
<input class="tab-input" id="tab-set--6-input--2" name="tab-set--6" type="radio"><label class="tab-label" for="tab-set--6-input--2">英文</label><div class="tab-content docutils container">
<p>As we saw in Chapter 2, GIS, projecting features from the three-dimensional surface
of the Earth onto a two-dimensional Cartesian plane can never be done perfectly.
It is a mathematical truism that there will always be errors in any projection.</p>
<p>Different map projections are generally chosen to preserve values such as distance
or area for a particular portion of the Earth’s surface. For example, the Mercator
projection is accurate at the tropics but distorts features closer to the poles.</p>
<p>Because of this inevitable distortion, projected coordinates work best when your
geospatial data only covers a part of the Earth’s surface. If you are only dealing
with data for Austria, then a projected coordinate system will work very well
indeed. But if your data includes features in both Austria and Australia, then
using the same projected coordinates for both sets of features will once again
produce inaccurate results.</p>
<p>For this reason, it is generally best to use a projected coordinate system for data that
covers only part of the Earth’s surface, but unprojected coordinates will work best if
you need to store data covering large parts of the Earth.</p>
<p>Of course, using unprojected coordinates leads to problems of its own, as discussed
earlier. This is why it is recommended that you use the appropriate spatial reference
for your particular needs; what is appropriate for you depends on what data you
need to store and how you intend to use it.</p>
<p>The best way to find out what is appropriate would be to experiment; try importing
your data in both spatial references, and write some test programs to work with the
imported data. This will tell you which is the fastest and easiest spatial reference to
work with, rather than having to guess.</p>
</div>
</div>
</section>
</section>
<section id="id8">
<h2>避免在查询中进行即时转换<a class="headerlink" href="#id8" title="此标题的永久链接">#</a></h2>
<p>Avoiding on-the-fly transformations within a query</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--7-input--1" name="tab-set--7" type="radio"><label class="tab-label" for="tab-set--7-input--1">中文</label><div class="tab-content docutils container">
<p>假设你有一个包含 POLYGON 几何数据的 <cite>cities</cite> 表，<cite>geom</cite> 列中的数据使用的是 UTM 12N 投影坐标系 (EPSG 32612)。作为一个有能力的地理空间开发者，你已经在这个列上设置了空间索引。</p>
<p>现在，假设你有一个名为 <cite>pt</cite> 的变量，保存的是使用未经投影的 WGS84 坐标系 (EPSG 4326) 的 POINT 几何数据。你可能想要查找包含这个点的城市，因此你会发出以下合理的查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span>
<span class="w">                    </span><span class="k">Contains</span><span class="p">(</span><span class="k">Transform</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="mi">4326</span><span class="p">),</span><span class="w"> </span><span class="n">pt</span><span class="p">);</span>
</pre></div>
</div>
<p>这个查询看起来是对的，但实际上执行起来会非常慢。为什么呢？因为 <cite>Transform(geom, 4326)</cite> 表达式会把表中的每个几何图形从 UTM 12N 转换为 WGS84 坐标系，然后数据库才能检查该点是否在几何图形内部。空间索引完全被忽略，因为它是基于错误的坐标系。</p>
<p>将其与下面的查询进行对比：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span>
<span class="w">                    </span><span class="k">Contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="k">Transform</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="w"> </span><span class="mi">32612</span><span class="p">));</span>
</pre></div>
</div>
<p>这只是一个非常小的修改，却能带来截然不同的结果。执行时间不再是几个小时，而是几乎瞬间得到结果。你能明白为什么吗？因为转换操作只对一个变量进行，而这个变量在每一条记录中都不变，所以 <cite>Transform(pt, 32612)</cite> 只会被调用一次，<cite>Contains()</cite> 函数可以利用你的空间索引快速找到匹配的城市。</p>
<p>这里的教训很简单：要注意你要求数据库执行什么操作，确保你的查询结构能够避免对大量几何图形进行即时转换。</p>
</div>
<input class="tab-input" id="tab-set--7-input--2" name="tab-set--7" type="radio"><label class="tab-label" for="tab-set--7-input--2">英文</label><div class="tab-content docutils container">
<p>Imagine that you have a cities table with a geom column containing POLYGON
geometries in UTM 12N projection (EPSG number 32612). Being a competent
geospatial developer, you have set up a spatial index on this column.</p>
<p>Now, imagine that you have a variable named pt that holds a POINT geometry in
unprojected WGS84 coordinates (EPSG number 4326). You might want to find the city
that contains this point, so you would issue the following reasonable-looking query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span>
<span class="w">                </span><span class="k">Contains</span><span class="p">(</span><span class="k">Transform</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="mi">4326</span><span class="p">),</span><span class="w"> </span><span class="n">pt</span><span class="p">);</span>
</pre></div>
</div>
<p>This would give you the right answer, but would take an extremely long time.
Why is it that? Because the <em>Transform(geom, 4326)</em> expression is converting every
geometry in the table from UTM 12N to WGS84 coordinates before the database
can check to see if the point is inside the geometry. The spatial index is completely
ignored, as it is in the wrong coordinate system.</p>
<p>Compare this with the following query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span>
<span class="w">                </span><span class="k">Contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="k">Transform</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="w"> </span><span class="mi">32612</span><span class="p">));</span>
</pre></div>
</div>
<p>A very minor change, but a dramatically different result. Instead of taking hours, the
answer should come back almost immediately. Can you see why? The transformation
is being done on a variable that does not change from one record to the next, so the
<em>Transform(pt, 32612)</em> expression is being called just once, and the <em>Contains()</em> call
can make use of your spatial index to quickly find the matching city.</p>
<p>The lesson here is simple: be aware of what you are asking the database to do, and
make sure you structure your queries to avoid on-the-fly transformations of large
numbers of geometries.</p>
</div>
</div>
</section>
<section id="id9">
<h2>不要在查询中创建几何图形<a class="headerlink" href="#id9" title="此标题的永久链接">#</a></h2>
<p>Don’t create geometries within a query</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--8-input--1" name="tab-set--8" type="radio"><label class="tab-label" for="tab-set--8-input--1">中文</label><div class="tab-content docutils container">
<p>在我们讨论可能导致数据库执行大量工作的数据库查询时，考虑以下情况（其中 <cite>poly</cite> 是一个多边形）：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span>
<span class="w">                    </span><span class="k">NOT</span><span class="w"> </span><span class="n">ST_IsEmpty</span><span class="p">(</span><span class="n">ST_Intersection</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="n">poly</span><span class="p">));</span>
</pre></div>
</div>
<p>从某种意义上讲，这完全是合理的：找出所有城市，这些城市的轮廓与给定多边形之间有非空的交集。数据库确实能够回答这个查询——只是执行起来会非常慢。希望你能理解为什么；<cite>ST_Intersection()</cite> 函数会基于两个已有几何图形创建一个新几何图形。这意味着，对于数据库表中的每一行，都会创建一个新几何图形，然后将其传递给 <cite>ST_IsEmpty()</cite>。正如你可以想象的那样，这类操作效率极低。为了避免每次都创建新的几何图形，你可以将查询改写为：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="n">poly</span><span class="p">);</span>
</pre></div>
</div>
<p>虽然这个例子看起来很显而易见，但在很多情况下，空间开发者忘记了这个规则，并且曾经困惑于为什么他们的查询执行得这么慢。一个常见的例子是使用 <cite>ST_Buffer()</cite> 函数来检查某点是否在多边形的给定距离内，像这样：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span>
<span class="w">        </span><span class="n">ST_Contains</span><span class="p">(</span><span class="n">ST_Buffer</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">),</span><span class="w"> </span><span class="n">pt</span><span class="p">);</span>
</pre></div>
</div>
<p>同样，这个查询是可以工作的，但会非常慢。一个更好的方法是使用 <cite>ST_DWithin()</cite> 函数：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">ST_DWithin</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
</pre></div>
</div>
<p>作为一个一般规则，记住你永远不应该在 <cite>SELECT</cite> 语句的 <cite>WHERE</cite> 部分调用任何返回几何对象（或其子类）的函数。</p>
</div>
<input class="tab-input" id="tab-set--8-input--2" name="tab-set--8" type="radio"><label class="tab-label" for="tab-set--8-input--2">英文</label><div class="tab-content docutils container">
<p>While we are discussing database queries that can cause the database to perform
a huge amount of work, consider the following (where poly is a polygon):</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span>
<span class="w">                </span><span class="k">NOT</span><span class="w"> </span><span class="n">ST_IsEmpty</span><span class="p">(</span><span class="n">ST_Intersection</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="n">poly</span><span class="p">));</span>
</pre></div>
</div>
<p>In a sense this is perfectly reasonable: identify all cities which have a nonempty
intersection between the city’s outline and the given polygon. And the database
will indeed be able to answer this query—it will just take an extremely long time
to do so. Hopefully you can see why; the ST_Intersection() function creates
a new geometry out of two existing geometries. This means that for every row in
the database table, a new geometry is created, and is then passed to ST_IsEmpty().
As you can imagine, these types of operations are extremely inefficient. To avoid
creating a new geometry each time, you can rephrase your query like this:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="n">poly</span><span class="p">);</span>
</pre></div>
</div>
<p>While this example may seem obvious, there are many cases where spatial
developers have forgotten this rule, and have wondered why their queries
were taking so long to complete. A common example is to use the ST_Buffer()
function to see if a point is within a given distance of a polygon, like this:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span>
<span class="w">    </span><span class="n">ST_Contains</span><span class="p">(</span><span class="n">ST_Buffer</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">),</span><span class="w"> </span><span class="n">pt</span><span class="p">);</span>
</pre></div>
</div>
<p>Once again, this query will work, but will be painfully slow. A much better approach
would be to use the ST_DWithin() function:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">ST_DWithin</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
</pre></div>
</div>
<p>As a general rule, remember that you never want to call any function which
returns a Geometry object (or one of its subclasses) within the WHERE portion
of a SELECT statement.</p>
</div>
</div>
<section id="id10">
<h3>适当使用空间索引<a class="headerlink" href="#id10" title="此标题的永久链接">#</a></h3>
<p>Using spatial indexes appropriately</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--9-input--1" name="tab-set--9" type="radio"><label class="tab-label" for="tab-set--9-input--1">中文</label><div class="tab-content docutils container">
<p>就像普通的数据库索引能极大地提高数据库的速度和效率一样，空间索引也是加速数据库查询的非常强大的工具。然而，像所有强大的工具一样，它们也有其局限性：</p>
<ul class="simple">
<li><p>如果你没有显式地定义空间索引，数据库就无法使用它。相反，如果你有过多的空间索引，数据库会变慢，因为每次添加、更新或删除记录时，都需要更新每个索引。因此，至关重要的是定义正确的空间索引集：仅对你要搜索的信息进行索引，其他不需要索引的内容则不要索引。</p></li>
<li><p>由于空间索引是基于几何图形的边界框工作的，索引本身只能告诉你哪些边界框确实有重叠或相交关系；它不能告诉你底层的点、线或多边形是否有这种关系。因此，它们实际上只是搜索你所需信息的第一步。在 PostGIS 和 SpatiaLite 中，数据库本身可以进一步细化搜索，比较单独的几何图形；而在 MySQL 中，你必须自己执行这一步，如我们之前所看到的那样。</p></li>
<li><p>空间索引在处理大量相对较小的几何图形时最为高效。如果你的多边形覆盖的面积很大，那么这些多边形的边界框将非常大，以至于它们会与许多其他几何图形相交，数据库就不得不转而进行完整的多边形计算，而不仅仅是边界框计算。此外，如果你的几何图形包含成千上万个顶点，那么这些计算可能会非常慢——整个多边形必须加载到内存中，并逐个顶点进行处理。如果你有既大又复杂的多边形，那么你的空间查询将会变慢。如果可能，通常最好将大型复杂的多边形（和多多边形）拆分成较小的部分，这样空间索引就能更高效地处理它们。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>我们将在第7章《处理空间数据》中重新讨论这个问题，在那里我们将拆分大多边形成更小的部分，以加速程序。</p>
</div>
</div>
<input class="tab-input" id="tab-set--9-input--2" name="tab-set--9" type="radio"><label class="tab-label" for="tab-set--9-input--2">英文</label><div class="tab-content docutils container">
<p>Just as ordinary database indexes can make an immense difference to the speed and efficiency of your database, spatial indexes are also a very powerful tool for speeding up your database queries. Like all powerful tools, though, they have their limits:</p>
<ul class="simple">
<li><p>If you don’t explicitly define a spatial index, the database can’t use it. Conversely, if you have too many spatial indexes, the database will slow down because each index needs to be updated every time a record is added, updated or deleted. Thus, it is crucial that you define the right set of spatial indexes: index the information you are going to search on, and nothing more.</p></li>
<li><p>Because spatial indexes work on the geometries’ bounding boxes, the index itself can only tell you which bounding boxes actually overlap or intersect; they can’t tell you if the underlying points, lines, or polygons have this relationship. Thus, they are really only the first step in searching for the information you want. With PostGIS and SpatiaLite, the database itself can further refine the search by comparing the individual geometries for you; with MySQL, you have to do this yourself, as we saw earlier.</p></li>
<li><p>Spatial indexes are most efficient when dealing with lots of relatively small geometries. If your polygons cover a large area, the polygon bounding boxes are going to be so large that they will intersect with many other geometries, and the database will have to revert to doing full polygon calculations rather than just the bounding box. Furthermore, if your geometries consist of many thousands of vertices, these calculations can be very slow indeed—the entire polygon will have to be loaded into memory and processed one vertex at a time. If you have polygons that are both large and complex, your spatial queries will be slow. If possible, it is generally better to split large and complex polygons (and multipolygons) into smaller pieces so that the spatial index can work with them more efficiently.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>We will revisit this issue in Chapter 7, Working with Spatial Data, where we’ll split large polygons into smaller ones to speed up our program.</p>
</div>
</div>
</div>
</section>
</section>
<section id="id11">
<h2>了解数据库查询优化器的限制<a class="headerlink" href="#id11" title="此标题的永久链接">#</a></h2>
<p>Knowing the limits of your database’s query optimizer</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--10-input--1" name="tab-set--10" type="radio"><label class="tab-label" for="tab-set--10-input--1">中文</label><div class="tab-content docutils container">
<p>当你向数据库发送查询时，它会自动尝试优化查询，以避免不必要的计算并利用任何可用的索引。例如，如果你发出以下（非空间）查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">people</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="n">Concat</span><span class="p">(</span><span class="ss">&quot;John &quot;</span><span class="p">,</span><span class="ss">&quot;Doe&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>数据库会知道 <cite>Concat(“John “,”Doe”)</cite> 产生的是一个常量，因此它会在发出查询之前只计算一次。它还会查找 <cite>name</cite> 列上的数据库索引，并使用它来加速操作。此类查询优化非常强大，背后的逻辑非常复杂。同样，空间数据库也有空间查询优化器，它会寻找预计算值的方式，并利用空间索引来加速查询。</p>
<p>例如，考虑以下来自上一节的空间查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">ST_DWithin</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>在这种情况下，PostGIS 函数 <cite>ST_DWithin()</cite> 给定了一个来自表格的几何图形（<cite>outline</cite>），以及一个作为固定值指定的第二个几何图形（<cite>pt</cite>），并附带一个所需的距离（12.5 “单位”，这在几何的空间参考中是指什么）。查询优化器知道如何高效地处理此操作：首先计算固定几何图形加上所需距离的边界框（<cite>pt ± 12.5</cite>），然后使用空间索引快速识别可能其轮廓几何图形位于该扩展边界框内的记录。</p>
<p>虽然数据库的查询优化器有时看起来能够做到魔法般的优化，但也有许多时候它表现得异常愚笨。成为一名优秀数据库开发人员的艺术之一就是深入了解你的数据库查询优化器的工作原理，知道它什么时候不能工作——以及如何应对这种情况。</p>
<p>接下来我们将看看如何在我们的三个空间数据库中，了解更多关于查询优化过程的信息。</p>
</div>
<input class="tab-input" id="tab-set--10-input--2" name="tab-set--10" type="radio"><label class="tab-label" for="tab-set--10-input--2">英文</label><div class="tab-content docutils container">
<p>When you send a query to the database, it automatically attempts to optimize the
query to avoid unnecessary calculations and to make use of any available indexes.
For example, if you issued the following (nonspatial) query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">people</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="n">Concat</span><span class="p">(</span><span class="ss">&quot;John &quot;</span><span class="p">,</span><span class="ss">&quot;Doe&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The database would know that Concat(“John “,”Doe”) yields a constant, and
so would only calculate it once before issuing the query. It would also look for a
database index on the name column, and use it to speed up the operation.
This type of query optimization is very powerful, and the logic behind it is extremely
complex. In a similar way, spatial databases have a spatial query optimizer that looks
for ways to precalculate values and make use of spatial indexes to speed up the query.
For example, consider this spatial query from the previous section:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">ST_DWithin</span><span class="p">(</span><span class="n">outline</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, the PostGIS function ST_DWithin() is given one geometry taken from
a table (outline), and a second geometry that is specified as a fixed value (pt),
along with a desired distance (12.5 “units”, whatever that means in the geometry’s
spatial reference). The query optimizer knows how to handle this efficiently, by first
precalculating the bounding box for the fixed geometry plus the desired distance
(pt ±12.5), and then using a spatial index to quickly identify the records which
may have their outline geometry within that extended bounding box.</p>
<p>While there are times when the database’s query optimizer seems to be capable of
magic, there are many other times when it is incredibly stupid. Part of the art of
being a good database developer is to have a keen sense of how your database’s
query optimizer works, when it doesn’t—and what to do about it.</p>
<p>Let’s see how you can find out more about the query optimization process in each
of our three spatial databases.</p>
</div>
</div>
<section id="mysql">
<h3>MySQL<a class="headerlink" href="#mysql" title="此标题的永久链接">#</a></h3>
<p>MySQL</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--11-input--1" name="tab-set--11" type="radio"><label class="tab-label" for="tab-set--11-input--1">中文</label><div class="tab-content docutils container">
<p>MySQL 提供了一个命令 <cite>EXPLAIN SELECT</cite>，它告诉你查询优化器将如何处理你的查询。例如：</p>
<div class="highlight-mysql notranslate"><div class="highlight"><pre><span></span>mysql&gt; EXPLAIN SELECT * FROM cities
            WHERE MBRContains(geom,
                                GeomFromText(pt))\G
*********************** 1. row ***********************
            id: 1
    select_type: SIMPLE
        table: cities
            type: range
possible_keys: geom
            key: geom
        key_len: 34
            ref: NULL
            rows: 1
        Extra: Using where
1 row in set (0.00 sec)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>不必担心命令末尾的 <cite>G</cite>，它只是以一种更易于阅读的方式格式化输出。</p>
</div>
<p>此命令告诉你，这个查询涉及一个简单的搜索，搜索 <cite>cities</cite> 表中的记录，并使用 <cite>geom</cite> 空间索引来加速结果。<cite>rows:1</cite> 告诉你，查询优化器认为它只需要从表中读取一行记录即可找到结果。</p>
<p>这很好。现在对比以下查询：</p>
<div class="highlight-mysql notranslate"><div class="highlight"><pre><span></span>mysql&gt; EXPLAIN SELECT * FROM cities
            WHERE MBRContains(Envelope(geom),
                                GeomFromText(pt))\G
*********************** 1. row ***********************
            id: 1
    select_type: SIMPLE
        table: cities
            type: ALL
possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
            rows: 34916
        Extra: Using where
1 row in set (0.00 sec)
</pre></div>
</div>
<p>这个查询使用了 <cite>Envelope()</cite> 函数来创建一个新的几何图形，然后检查它是否包含给定的点。正如 <em>不要在查询中创建几何图形</em> 部分所解释的，数据库必须为表中的每一行创建一个新几何图形。在这种情况下，查询优化器无法使用索引，如 <cite>possible_keys</cite> 和 <cite>key</cite> 的 <cite>NULL</cite> 值所示。它还告诉你，它必须扫描 34,916 条记录来找到匹配的点——这显然不是一个高效的查询。事实上，运行这个查询可能需要几分钟才能完成。</p>
</div>
<input class="tab-input" id="tab-set--11-input--2" name="tab-set--11" type="radio"><label class="tab-label" for="tab-set--11-input--2">英文</label><div class="tab-content docutils container">
<p>MySQL provides a command, EXPLAIN SELECT, that tells you how the query optimizer will process your query. For example:</p>
<div class="highlight-mysql notranslate"><div class="highlight"><pre><span></span>mysql&gt; EXPLAIN SELECT * FROM cities
            WHERE MBRContains(geom,
                              GeomFromText(pt))\G
*********************** 1. row ***********************
           id: 1
  select_type: SIMPLE
        table: cities
         type: range
possible_keys: geom
          key: geom
      key_len: 34
          ref: NULL
         rows: 1
        Extra: Using where
1 row in set (0.00 sec)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Don’t worry about the G at the end of the command; this just formats the output in a way which makes it easier to read.</p>
</div>
<p>This command tells you that this query involves a simple search against the cities
table, searching for a range of records using the geom spatial index to speed up the
results. The rows:1 tells you that the query optimizer thinks it only needs to read a
single row from the table to find the results.</p>
<p>This is good. Compare it with the following:</p>
<div class="highlight-mysql notranslate"><div class="highlight"><pre><span></span>mysql&gt; EXPLAIN SELECT * FROM cities
            WHERE MBRContains(Envelope(geom),
                              GeomFromText(pt))\G
*********************** 1. row ***********************
           id: 1
  select_type: SIMPLE
        table: cities
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 34916
        Extra: Using where
1 row in set (0.00 sec)
</pre></div>
</div>
<p>This query uses the <em>Envelope()</em> function to create a new geometry, which is then checked to see if it contains the given point. As explained in the <em>Don’t Create Geometries Within a Query</em> section, the database has to create a new geometry for every row in the table. In this case the query optimizer cannot use an index, as shown by the NULL value for possible_keys and key. It also tells you that it would have to scan through 34,916 records to find the matching points—not exactly an efficient query. Indeed, running this query could take several minutes to complete.</p>
</div>
</div>
</section>
<section id="postgis">
<h3>PostGIS<a class="headerlink" href="#postgis" title="此标题的永久链接">#</a></h3>
<p>PostGIS</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--12-input--1" name="tab-set--12" type="radio"><label class="tab-label" for="tab-set--12-input--1">中文</label><div class="tab-content docutils container">
<p>MySQL 使用一种理论方法来进行查询优化，仅通过查询本身来查看如何优化查询。另一方面，PostGIS 会考虑数据库中的信息量以及这些信息的分布情况。为了使其良好工作，PostGIS 查询优化器需要数据库内容的最新统计信息。然后，它使用一种复杂的遗传算法来确定执行特定查询的最有效方式。</p>
<p>因此，你需要定期运行 <cite>VACUUM ANALYZE</cite> 命令，收集数据库的统计信息，以便查询优化器能够尽可能高效地工作。如果不运行 <cite>VACUUM ANALYZE</cite>，优化器就无法正常工作。</p>
<p>以下是如何通过 Python 运行 <cite>VACUUM ANALYZE</cite> 命令的示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">psycopg2</span>

<span class="n">connection</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;dbname=... user=...&quot;</span><span class="p">)</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">old_level</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">isolation_level</span>
<span class="n">connection</span><span class="o">.</span><span class="n">set_isolation_level</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;VACUUM ANALYZE&quot;</span><span class="p">)</span>
<span class="n">connection</span><span class="o">.</span><span class="n">set_isolation_level</span><span class="p">(</span><span class="n">old_level</span><span class="p">)</span>
</pre></div>
</div>
<p>不用担心 <cite>isolation_level</cite> 逻辑；这只是通过基于事务的 psycopg2 适配器让你在 Python 中运行 <cite>VACUUM ANALYZE</cite> 命令。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>可以设置一个自动清理守护进程，它会在一定时间后自动运行，或者当表的内容发生足够变化时自动运行清理。设置自动清理守护进程超出了本书的范围。</p>
</div>
<p>一旦你运行了 <cite>VACUUM ANALYZE</cite> 命令，查询优化器就能够开始优化你的查询。与 MySQL 一样，你可以通过 <cite>EXPLAIN SELECT</cite> 命令查看查询优化器的工作情况：</p>
<div class="highlight-mysql notranslate"><div class="highlight"><pre><span></span><span class="n">psql</span><span class="o">&gt;</span><span class="w"> </span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span>
<span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="nf">ST_Contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="n">pt</span><span class="p">);</span>

<span class="w">                    </span><span class="k">QUERY</span><span class="w"> </span><span class="n">PLAN</span>
<span class="o">--------------------------------------------------------</span>
<span class="n">Seq</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.7.51</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">2619</span><span class="p">)</span>
<span class="w">    </span><span class="k">Filter</span><span class="o">:</span><span class="w"> </span><span class="p">((</span><span class="n">geom</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="s1">&#39;010100000000000000000000000000000000000000&#39;</span><span class="o">::</span><span class="kt">geometry</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">_st_</span>
<span class="k">contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;010100000000000000000000000000000000000000&#39;</span><span class="o">::</span><span class="kt">geometry</span><span class="p">))</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="k">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>不用担心 <cite>Seq Scan</cite> 部分；这个表中的记录非常少，所以 PostGIS 知道扫描整个表比读取索引要快。当数据库变大时，它会自动开始使用索引来快速定位所需记录。</p>
<p><cite>cost=</cite> 部分表示此查询的“成本”，以任意单位衡量，默认情况下相对数据从磁盘读取的时间。两个数字分别表示“启动成本”（开始处理第一行所需的时间）和估算的总成本（处理表中每条记录所需的时间）。由于从磁盘读取数据的速度相当快，总成本为 7.51 非常快速。</p>
<p>这个解释中最有趣的部分是 <cite>Filter</cite>。让我们仔细看看 <cite>EXPLAIN SELECT</cite> 命令告诉我们 PostGIS 如何筛选这个查询。第一部分如下：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(geom &amp;&amp; &#39;010100000000000000000000000000000000000000&#39;::geometry)</span>
</pre></div>
</div>
<p>这使用了 <cite>&amp;&amp;</cite> 操作符，利用空间索引中定义的包围盒搜索匹配的记录。过滤条件的第二部分是：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">_st_contains(geom,</span>
<span class="go">&#39;010100000000000000000000000000000000000000&#39;::geometry)</span>
</pre></div>
</div>
<p>这使用 <cite>ST_Contains()</cite> 函数来识别实际包含给定点的几何图形。这一两步过程（首先按包围盒过滤，然后按几何图形本身过滤）正是我们在使用 MySQL 时必须手动实现的。正如你所看到的，PostGIS 会自动为我们执行这些操作，从而快速准确地查找包含给定点的几何图形。</p>
</div>
<input class="tab-input" id="tab-set--12-input--2" name="tab-set--12" type="radio"><label class="tab-label" for="tab-set--12-input--2">英文</label><div class="tab-content docutils container">
<p>MySQL uses a theoretical approach to query optimization, looking only at the query
itself to see how it could be optimized. PostGIS, on the other hand, takes into account
the amount of information in the database and how it is distributed. In order to
work well, the PostGIS query optimizer needs to have up-to-date statistics on the
database’s contents. It then uses a sophisticated genetic algorithm to determine the
most effective way to run a particular query.</p>
<p>Because of this approach, you need to regularly run the VACUUM ANALYZE command,
which gather statistics on the database so that the query optimizer can work as
effectively as possible. If you don’t run VACUUM ANALYZE, the optimizer simply
won’t be able to work.</p>
<p>Here is how you can run the VACUUM ANALYZE command from Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">psycopg2</span>

<span class="n">connection</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;dbname=... user=...&quot;</span><span class="p">)</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">old_level</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">isolation_level</span>
<span class="n">connection</span><span class="o">.</span><span class="n">set_isolation_level</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;VACUUM ANALYZE&quot;</span><span class="p">)</span>
<span class="n">connection</span><span class="o">.</span><span class="n">set_isolation_level</span><span class="p">(</span><span class="n">old_level</span><span class="p">)</span>
</pre></div>
</div>
<p>Don’t worry about the isolation_level logic here; that just allows you to run the VACUUM ANALYZE command from Python using the transaction-based psycopg2 adapter.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>It is possible to set up an autovacuum daemon that runs automatically after a given period of time, or after a table’s contents has changed enough to warrant another vacuum. Setting up an autovacuum daemon is beyond the scope of this book.</p>
</div>
<p>Once you have run the VACUUM ANALYZE command, the query optimizer will be
able to start optimizing your queries. As with MySQL, you can see how the query
optimizer works using the EXPLAIN SELECT command:</p>
<div class="highlight-mysql notranslate"><div class="highlight"><pre><span></span><span class="n">psql</span><span class="o">&gt;</span><span class="w"> </span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span>
<span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="nf">ST_Contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="n">pt</span><span class="p">);</span>

<span class="w">                    </span><span class="k">QUERY</span><span class="w"> </span><span class="n">PLAN</span>
<span class="o">--------------------------------------------------------</span>
<span class="n">Seq</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.7.51</span><span class="w"> </span><span class="k">rows</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">2619</span><span class="p">)</span>
<span class="w">    </span><span class="k">Filter</span><span class="o">:</span><span class="w"> </span><span class="p">((</span><span class="n">geom</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="s1">&#39;010100000000000000000000000000000000000000&#39;</span><span class="o">::</span><span class="kt">geometry</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">_st_</span>
<span class="k">contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;010100000000000000000000000000000000000000&#39;</span><span class="o">::</span><span class="kt">geometry</span><span class="p">))</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="k">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>Don’t worry about the Seq Scan part; there are only a few records in this table,
so PostGIS knows that it can scan the entire table faster than it can read through
an index. When the database gets bigger, it will automatically start using the
index to quickly identify the desired records.</p>
<p>The cost= part is an indication of how much this query will “cost”, measured in
arbitrary units that by default are relative to how long it takes to read a page of data
from disk. The two numbers represent the “start up cost” (how long it takes before
the first row can be processed), and the estimated total cost (how long it would take
to process every record in the table). Since reading a page of data from disk is quite
fast, a total cost of 7.51 is very quick indeed.</p>
<p>The most interesting part of this explanation is the Filter. Let’s take a closer look
at what the EXPLAIN SELECT command tells us about how PostGIS will filter this
query. The first part is given here:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(geom &amp;&amp; &#39;010100000000000000000000000000000000000000&#39;::geometry)</span>
</pre></div>
</div>
<p>This makes use of the &amp;&amp; operator, which searches for matching records using the
bounding box defined in the spatial index. The second part of the filter condition is:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">_st_contains(geom,</span>
<span class="go">&#39;010100000000000000000000000000000000000000&#39;::geometry)</span>
</pre></div>
</div>
<p>This uses the ST_Contains() function to identify the exact geometries which actually
contain the desired point. This two-step process (first filtering by bounding box, then
by the geometry itself) is exactly what we had to implement manually when using
MySQL. As you can see, PostGIS does this for us automatically, resulting in a quick
and accurate search for geometries that contain a given point.</p>
</div>
</div>
</section>
<section id="spatialite">
<h3>SpatiaLite<a class="headerlink" href="#spatialite" title="此标题的永久链接">#</a></h3>
<p>SpatiaLite</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--13-input--1" name="tab-set--13" type="radio"><label class="tab-label" for="tab-set--13-input--1">中文</label><div class="tab-content docutils container">
<p>使用像 SpatiaLite 这样的轻量级数据库的一个缺点是其查询优化器相对较为简单。特别地，SpatiaLite 查询优化器仅会使用 B*Tree 索引；虽然可以创建空间 R-Tree 索引，但除非在查询中显式地包含它，否则它不会被使用。</p>
<p>例如，考虑以下 SQL 语句：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">AUTOINCREMENT</span><span class="p">,</span>
<span class="w">                    </span><span class="n">name</span><span class="w"> </span><span class="nb">CHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">));</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">AddGeometryColumn</span><span class="p">(</span><span class="s1">&#39;cities&#39;</span><span class="p">,</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span><span class="mi">4326</span><span class="p">,</span><span class="s1">&#39;POLYGON&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">geom</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;London&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">GeomFromText</span><span class="p">(</span><span class="n">wkt</span><span class="p">,</span><span class="w"> </span><span class="mi">4326</span><span class="p">));</span>
</pre></div>
</div>
<p>这创建了一个 <cite>cities</cite> 表，定义了空间索引并插入了一条记录。由于 SpatiaLite 使用触发器自动更新空间索引，因此每当记录被添加、更新或删除时，前面的语句会正确创建空间索引并在插入新记录时更新它。然而，如果我们接着执行以下查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="k">Contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">);</span>
</pre></div>
</div>
<p>SpatiaLite 查询优化器并不了解空间索引，因此会忽略它。我们可以使用 <cite>EXPLAIN QUERY PLAN</cite> 命令来确认这一点，它会显示查询使用的索引：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite</span><span class="o">&gt;</span><span class="w"> </span><span class="k">EXPLAIN</span><span class="w"> </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span>
<span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>

<span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="k">SEARCH</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">rowid</span><span class="o">&lt;?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="mi">250000</span><span class="w"> </span><span class="k">rows</span><span class="p">)</span>

<span class="n">sqlite</span><span class="o">&gt;</span><span class="w"> </span><span class="k">EXPLAIN</span><span class="w"> </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span>
<span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="k">Contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">);</span>

<span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="n">SCAN</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">cities</span>
</pre></div>
</div>
<p>第一个查询（<cite>WHERE id &lt; 100</cite>）使用了 B*Tree 索引，因此查询优化器知道要使用主键索引。第二个查询（<cite>WHERE Contains(geom, pt)</cite>）使用了查询优化器不知道的空间索引。在这种情况下，<cite>cities</cite> 表将被顺序扫描，完全不使用任何索引。这对于记录数较少的情况是可以接受的，但对于大型数据库来说，这将非常慢。</p>
<p>为了使用空间索引，我们必须在查询中显式地包含它：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">IN</span>
<span class="w">    </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">pkid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">idx_cities_geom</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">xmin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
<span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">xmax</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">ymin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">ymax</span><span class="p">);</span>
</pre></div>
</div>
<p><cite>EXPLAIN QUERY PLAN</cite> 命令告诉我们这个查询确实会使用数据库索引来加速查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite</span><span class="o">&gt;</span><span class="w"> </span><span class="k">EXPLAIN</span><span class="w"> </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span>
<span class="w">            </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">pkid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">idx_cities_geom</span>
<span class="w">                </span><span class="k">WHERE</span><span class="w"> </span><span class="n">xmin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">xmax</span>
<span class="w">                </span><span class="k">AND</span><span class="w"> </span><span class="n">ymin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">ymax</span><span class="p">);</span>

<span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="k">SEARCH</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">rowid</span><span class="o">=?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="mi">25</span>
<span class="k">rows</span><span class="p">)</span>
<span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="k">EXECUTE</span><span class="w"> </span><span class="n">LIST</span><span class="w"> </span><span class="n">SUBQUERY</span><span class="w"> </span><span class="mi">1</span>
<span class="mi">1</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="n">SCAN</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">idx_cities_geom</span><span class="w"> </span><span class="n">VIRTUAL</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="n">BaDbBcDd</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="mi">0</span>
<span class="k">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>这是使用 SpatiaLite 的一个不幸的结果：你必须在每个空间查询中显式地包含索引，否则它们根本不会被使用。这可能会让你创建空间查询变得更复杂，尽管最终结果的性能会非常好。</p>
</div>
<input class="tab-input" id="tab-set--13-input--2" name="tab-set--13" type="radio"><label class="tab-label" for="tab-set--13-input--2">英文</label><div class="tab-content docutils container">
<p>One of the disadvantages of using a lightweight database such as SpatiaLite is that
the query optimizer is rather naive. In particular, the SpatiaLite query optimizer will
only make use of B*Tree indexes; you can create a spatial R-Tree index, but it won’t
be used unless you explicitly include it in your query.</p>
<p>For example, consider the following SQL statements:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">AUTOINCREMENT</span><span class="p">,</span>
<span class="w">                    </span><span class="n">name</span><span class="w"> </span><span class="nb">CHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">));</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">AddGeometryColumn</span><span class="p">(</span><span class="s1">&#39;cities&#39;</span><span class="p">,</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span><span class="mi">4326</span><span class="p">,</span><span class="s1">&#39;POLYGON&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">geom</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;London&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">GeomFromText</span><span class="p">(</span><span class="n">wkt</span><span class="p">,</span><span class="w"> </span><span class="mi">4326</span><span class="p">);</span>
</pre></div>
</div>
<p>This creates a cities table, defines a spatial index and inserts a record into the table.
Because SpatiaLite uses triggers to automatically update the spatial index as records
are added, updated, or deleted, the preceding statements would correctly create the
spatial index and update it as the new record is inserted. However, if we then issue
the following query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="k">Contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">);</span>
</pre></div>
</div>
<p>The SpatiaLite query optimizer won’t know about the spatial index, and so will
ignore it. We can confirm this using the EXPLAIN QUERY PLAN command, which
shows the indexes used by the query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite</span><span class="o">&gt;</span><span class="w"> </span><span class="k">EXPLAIN</span><span class="w"> </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span>
<span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>

<span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="k">SEARCH</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">rowid</span><span class="o">&lt;?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="mi">250000</span><span class="w"> </span><span class="k">rows</span><span class="p">)</span>

<span class="n">sqlite</span><span class="o">&gt;</span><span class="w"> </span><span class="k">EXPLAIN</span><span class="w"> </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span>
<span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="k">Contains</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">);</span>

<span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="n">SCAN</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">cities</span>
</pre></div>
</div>
<p>The first query (WHERE id &lt; 100) makes use of a B*Tree index, and so the query
optimizer knows to use the primary key to index the query. The second query
(WHERE Contains(geom, pt)) uses the spatial index which the query optimizer
doesn’t know about. In this case, the cities table will be scanned sequentially,
without any index at all. This will be acceptable for small numbers of records,
but for large databases this will be very slow indeed.</p>
<p>To use the spatial index, we have to include it directly in the query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">IN</span>
<span class="w">    </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">pkid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">idx_cities_geom</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">xmin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
<span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">xmax</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">ymin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">ymax</span><span class="p">);</span>
</pre></div>
</div>
<p>The EXPLAIN QUERY PLAN command tells us that this query would indeed use the
database indexes to speed up the query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite</span><span class="o">&gt;</span><span class="w"> </span><span class="k">EXPLAIN</span><span class="w"> </span><span class="n">QUERY</span><span class="w"> </span><span class="n">PLAN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cities</span>
<span class="w">            </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">pkid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">idx_cities_geom</span>
<span class="w">                </span><span class="k">WHERE</span><span class="w"> </span><span class="n">xmin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">xmax</span>
<span class="w">                </span><span class="k">AND</span><span class="w"> </span><span class="n">ymin</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">ymax</span><span class="p">);</span>

<span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="k">SEARCH</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">rowid</span><span class="o">=?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="mi">25</span>
<span class="k">rows</span><span class="p">)</span>
<span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="k">EXECUTE</span><span class="w"> </span><span class="n">LIST</span><span class="w"> </span><span class="n">SUBQUERY</span><span class="w"> </span><span class="mi">1</span>
<span class="mi">1</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="n">SCAN</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">idx_cities_geom</span><span class="w"> </span><span class="n">VIRTUAL</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="n">BaDbBcDd</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="mi">0</span>
<span class="k">rows</span><span class="p">)</span>
</pre></div>
</div>
<p>This is an unfortunate consequence of using SpatiaLite: you have to include the indexes explicitly in every spatial query you make, or they won’t be used at all. This can make creating your spatial queries more complicated, though the performance of the end result will be excellent.</p>
</div>
</div>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="working.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">使用 Python 处理地理空间数据库</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="commerical.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">商业空间数据库</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                <a href="../copyright.html">Copyright</a> &#169; 2025, Erik Westra
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">建议的最佳做法</a><ul>
<li><a class="reference internal" href="#id2">使用数据库跟踪空间参考</a></li>
<li><a class="reference internal" href="#id3">使用适合您数据的空间参考</a><ul>
<li><a class="reference internal" href="#id4">选项 1 – 使用支持地理的数据库</a></li>
<li><a class="reference internal" href="#id5">选项 2 – 根据需要转换要素</a></li>
<li><a class="reference internal" href="#id6">选项 3 – 从一开始就转换要素</a></li>
<li><a class="reference internal" href="#id7">何时使用非投影坐标</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">避免在查询中进行即时转换</a></li>
<li><a class="reference internal" href="#id9">不要在查询中创建几何图形</a><ul>
<li><a class="reference internal" href="#id10">适当使用空间索引</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">了解数据库查询优化器的限制</a><ul>
<li><a class="reference internal" href="#mysql">MySQL</a></li>
<li><a class="reference internal" href="#postgis">PostGIS</a></li>
<li><a class="reference internal" href="#spatialite">SpatiaLite</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script src="../_static/translations.js"></script>
    </body>
</html>